---
title: "Longevity"
author: "C le"
output: html_document
---



# Project Overview
Two sample Mendelian Randomization Analysis on GWAS of human lifespan looking at new and known exposure relationships related to longevity outcomes.

## A. Exposures

Exposures are obtained from the mrbase.org website from the following catalogs
  - NHGRI-EBI GWAS catalog
  - MR BASE GWAS catalog
  - Gene Expression QTLs
  - Protein Level QTLs
  - Metabolite Level OTLs
  - Methylation Level QTLs

## B. Outcomes

### I. First Outcome: cases 90

Outcome Data obtained from CPMC that was utilized in Deelen et al., 2019 (https://pubmed.ncbi.nlm.nih.gov/31413261/). Exposure - Outcome relationships will be examined in persons whose longevity is in the 90th percentile using the rest of the cohort as the control.

Download Deelen outcomes and files for rsID mapping.

```{r, eval = FALSE}
#Mapping file from EasyQC. Place is data/outcomes/
system("wget https://homepages.uni-regensburg.de/~wit59712/easyqc/1000g/rsmid_map.1000G_ALL_p1v3.merged_mach_impute.v3.mergeindels.txt.gz")

#Deelen GWAS outcomes
system("wget ftp://ftp.ebi.ac.uk/pub/databases/gwas/summary_statistics/DeelenJ_31413261_GCST008598/Results_90th_percentile.txt.gz")

system("wget ftp://ftp.ebi.ac.uk/pub/databases/gwas/summary_statistics/DeelenJ_31413261_GCST008599/Results_99th_percentile.txt.gz")

```

Define functions

```{r}
strand_flippr <- function(effect_allele, non_effect_allele){
  require(dplyr)
  
  
}

# Define functions
strand_flippr <- function(DT){
  library(data.table)
  DT[STRAND=="-", chartr("ATGC","TACG",effect_allele)]
  DT[STRAND=="-", chartr("ATGC","TACG",non_effect_allele)]
  DT[,STRAND:="+"]
}


allele_matchr <- function(merge_dat, indel = "id"){
  library(data.table)
  library(stringr)
  #GTEx reference alleles. gtex_ref and gtex_alt.
  #GWAS alleles. effect_allele and non_effect_allele.
  #indel id = ID marks indels, indel nucleo = nucleotides are provided for indels
  #modify study result file to match reference file
  #everything same case
  merge_dat[,gtex_ref:=str_to_upper(gtex_ref)]
  merge_dat[,gtex_alt:=str_to_upper(gtex_alt)]
  merge_dat[,effect_allele:=str_to_upper(effect_allele)]
  merge_dat[,non_effect_allele:=str_to_upper(non_effect_allele)]
  if (indel == "id"){
    #convert GTEx reference indel alleles to I and D
    merge_dat[,ref_indel := 1]
    merge_dat[(gtex_ref == "A" | gtex_ref == "C" | gtex_ref == "G" | gtex_ref == "T") & (gtex_alt == "A" | gtex_alt == "C" | gtex_alt == "G" | gtex_alt == "T"), ref_indel := 0]
    merge_dat[ref_indel == 1, gtex_ref := "I"]
    merge_dat[ref_indel == 1, gtex_alt := "D"]
    #convert gwas indel alleles to I and D
    merge_dat[,gwas_indel := 1]
    merge_dat[(effect_allele == "A" | effect_allele == "C" | effect_allele == "G" | effect_allele == "T") & (non_effect_allele == "A" | non_effect_allele == "C" | non_effect_allele == "G" | non_effect_allele == "T"), gwas_indel := 0]
    merge_dat[gwas_indel == 1, effect_allele := "I"]
    merge_dat[gwas_indel == 1, non_effect_allele := "D"]
  } #end of if(indel == "id")

  #flip alleles marked as being on the - strand
  merge_dat <- strand_flippr(merge_dat)

  #test for matches as is. GTEx alleles aren't in a particular order.
  #gtex_ref is not effect or non-effect for GTEx. They are just the two different alleles for a variant
  merge_dat[, noMatch:=0]   
  merge_dat[gtex_ref!=effect_allele | gtex_alt!=non_effect_allele, noMatch := 1]
  #Was non-match because effect and other were switched in study results? 
  #Test for match with the other alleles, and if match, reset noMatch to 0.
  if(merge_dat[noMatch==1,.N] > 0){
    merge_dat[noMatch==1 & effect_allele == gtex_alt & non_effect_allele == gtex_ref, noMatch:=0] 
    #noMatch==1 if SNPs alleles don't match without checking for strand flips
  } #end of matching without strand flip
  
  #now look for matches after flipping strand
  if(merge_dat[noMatch==1, .N] > 0){
    merge_dat[noMatch==1, STRAND := "-"]     
    merge_dat <- strand_flippr(merge_dat)
    merge_dat[noMatch==1 & effect_allele == gtex_ref & non_effect_allele == gtex_alt, noMatch:=0] 
    merge_dat[noMatch==1 & effect_allele == gtex_alt & non_effect_allele == gtex_ref, noMatch:=0] 
  } #end of matching after strand flip
}


miss_to_NA <- function(DT){
  library(data.table)
  stopifnot(is.data.table(DT))
  for(j in seq_len(ncol(DT))){
    set(DT, which(is.nan(DT[[j]])), j, NA)
    set(DT, which(DT[[j]] == "nan"), j, NA)
    set(DT, which(DT[[j]] == "."), j, NA)
  }
}

chrpos_split <- function(DT){
  library(data.table)
  library(stringr)
  chr_pos <- str_split(DT$markerID, pattern = ":")
  newchr <- vapply(chr_pos, function(x) x[1], character(1))
  newchr <- gsub("[[:alpha:]]", "", newchr) #turns chrX, X, MT into ""
  newpos <- vapply(chr_pos, function(x) x[2], character(1))
  newpos <- gsub("[[:alpha:]]", "", newpos)
  DT[, chr := as.integer(newchr)] #"" coerced into NA
  DT[, position := as.integer(newpos)]
}


format_rawgwas <- function(iter_index){
  library(data.table)
  trait_sheet <- fread("trait_sheet.csv")
  input_path <- "data/gwas/raw/"
  output_path_metaX <- "data/gwas/formatted/"
  output_path_LDSC <- "data/ldsc/gwas_formatted/"
  #collect raw GWAS file characteristics from trait_sheet
  raw_ID <- trait_sheet$markerID[iter_index]
  fname_out <- trait_sheet$fname_out[iter_index]
  fname_in <- trait_sheet$filename[iter_index]
  raw_chr <- trait_sheet$chr[iter_index]
  raw_position <- trait_sheet$position[iter_index]
  raw_effect_allele <- trait_sheet$effect_allele[iter_index]
  raw_non_effect_allele <- trait_sheet$non_effect_allele[iter_index]
  raw_effect <- trait_sheet$effect[iter_index]
  raw_se <- trait_sheet$se[iter_index]
  raw_p <- trait_sheet$p[iter_index]
  raw_n <- trait_sheet$n[iter_index]

  #read raw GWAS file
  gwas <- fread(paste0("gunzip -c ", input_path, fname_in))
  miss_to_NA(gwas)
  #harmonize column names
  setnames(gwas, raw_ID, "markerID")
  setnames(gwas, raw_effect_allele, "effect_allele")
  setnames(gwas, raw_non_effect_allele, "non_effect_allele")
  setnames(gwas, raw_effect, "effect")
  if(!is.na(raw_chr)){
    setnames(gwas, raw_chr, "chr")
    setnames(gwas, raw_position, "position")
  } else {
    chrpos_split(gwas)
  }
  gwas <- gwas[!is.na(chr)]
  gwas <- gwas[!is.na(position)]
  gwas <- gwas[!is.na(effect)]
  gwas[, effect := as.double(effect)]
  if(trait_sheet$OR[iter_index] == "y"){
    gwas[,effect := log(effect)]
  }
  if(!is.na(raw_se)){
    setnames(gwas, raw_se, "se")
    gwas[,se := as.double(se) ]
  }
  if(!is.na(raw_p)){
    setnames(gwas, raw_p, "p")
    gwas[, p := as.double(p)]
    gwas[p < 1e-300, p := 1e-300]
  }
  ## if P-value is missing but effect and se are not, calculate P-value
  if(is.na(raw_p) & !is.na(raw_se) & !is.na(raw_effect)){
    gwas[, p := pnorm(effect/se, lower.tail = FALSE)*2 ]
    gwas[p < 1e-300, p := 1e-300]
  }
  ## if SE is missing but effect and P-value are not, calculate SE
  if(!is.na(raw_p) & !is.na(raw_effect)  & is.na(raw_se)){
    gwas <- gwas[!is.na(p)]
    gwas[, z := qnorm(p/2, lower.tail = FALSE)]
    gwas[, se := effect/z]
  }

  nStart <- gwas[,.N]
  gwas[, SNPorder := 1:nStart]

  gwas <- merge(gwas,map_gtex,by.x=c("chr","position") ,by.y=c("gtex_chr", "gtex_position"),all.x=T)
  gwas[,STRAND:="+"]
  allele_matchr(gwas)
  gwas[, keep_dup:=0L]
  gwas[, grp_order:=0L]
  #clean up duplicates
  #gwas[base::duplicated(SNPorder), .N]
  dup_snporder <- unique(gwas[base::duplicated(SNPorder),SNPorder])
  gwas[!SNPorder %in% dup_snporder, keep_dup := 1L]
  #select one row from each SNPorder group
  for (i in seq_along(dup_snporder)){
    #create counter for each dup group
    grp_n <- gwas[SNPorder == dup_snporder[i], .N]
    gwas[SNPorder == dup_snporder[i], grp_order := 1:grp_n  ]
    if(gwas[SNPorder == dup_snporder[i] & noMatch == 0, .N ] == 0 ){
      #if there are no position and allele matches among the dups, take the first one
      gwas[SNPorder == dup_snporder[i] & grp_order == 1L, keep_dup := 1L ]
    } else if (gwas[SNPorder == dup_snporder[i] & noMatch == 0, .N] == 1 ){
      #if there is only one match, select it
      gwas[SNPorder == dup_snporder[i] & noMatch == 0, keep_dup := 1L]
    } else {
      #if there are multiple matches, select the first of the matches
      grp_order_multi <- gwas[SNPorder == dup_snporder[i] & noMatch == 0, min(grp_order) ]
      gwas[SNPorder == dup_snporder[i] & noMatch == 0 & grp_order == grp_order_multi, keep_dup := 1L]
    }
  }# end of for i loop over dups

  #remove duplicated rows that don't match
  gwas <- gwas[keep_dup == 1L]
  gwas <- gwas[order(SNPorder)]
  nEnd <- gwas[,.N]
  if(nStart != nEnd | sum(1:nEnd != gwas[,SNPorder])>0){
    print (paste0(fname_in, " has a SNPorder error")) 
  }
  #change name of GTEx rsID to rsID. Use this with MetaXcan input
  setnames(gwas, "rsid_gtex", "rsID")
  #only keep SNPs with rsIDs in GTEx annotation
  gwas <- gwas[!is.na(rsID)]
  #select cols
  gwas <- gwas[,.(rsID, chr, position, effect_allele, non_effect_allele, effect, se, p)]
  setkey(gwas, chr)
  fwrite(gwas, file=paste0(output_path_metaX, fname_out,"_metaX.csv"), na="NA", quote=F)
  gwas[,N := raw_n]
  fwrite(gwas, file=paste0(output_path_LDSC, fname_out,".txt"), na="NA", quote=F, sep="\t")
}



```

```{r}
require(tidyverse)
outcome <- read_delim("data/outcomes/Results_90th_percentile.txt.gz", delim = "\t")

```

### II. Second outcome: cases 99

Using data from section I, compare persons in the 90th percentile with persons in the 99th percentile. 

### III. Third Outcome: UK Biobank

Compare persons in the 90th percentile from section I to those in the 90th percentile from the UK Biobank

### IV. Fourth Outcome: UK Biobank Parental Longevity
## C. Preparation of Data

### I. Load Libraries
```{r}
library(TwoSampleMR)
library(MRInstruments)
library(tidyverse) #so we can use purrr::map, and no, not just because I got cats
library(knitr)
library(ieugwasr)
library(arsenal)
library(tidyverse) #why loaded twice?
```

###II.  Exposures from each catalog


#### a. GWAS Catalog

```{r, cache = TRUE}

#cache = True will create a folder that saves objects, and if objects and code aren't updated, this code chunk will not re-run. This is good for long-running code sections.
#import gwas catalog into R
data(gwas_catalog)
#gwas_catalog

#create a vector of unique gwas phenotypes
gwas_unique <- gwas_catalog %>%
  filter(!duplicated(Phenotype)) %>%
  pull(Phenotype)
# 3590 unique phenotypes in catalog

#make a for loop to create a database of exposure SNPs formatted for exposure data and clumped
#Initialize a list to save results. The problem with creating an empty dataframe with data.frame() is that it doesn't preallocate memory for 3590 rows. Instead, it creates an empty DF with zero rows.

exposures_gwas <- vector(mode = "list", length = length(gwas_unique))
for(i in seq_along(gwas_unique)){
  #you can test with for(i in 1:5)
# for(i in 1 : length(gwas_unique)) {
  #format exposure data and clump by LD r2 <0.001 to reduce covariance
  #combined both steps together. Send output to each element of list
  exposures_gwas[[i]] <- gwas_catalog %>%
    filter(Phenotype == gwas_unique[i]) %>%
    format_data %>%
    clump_data
  
  print(paste0("Last successful run was ", gwas_unique[i], 
               " which is iterator ", i))
}

#rbind list elements into DF
#old way of doing things
#exposures_gwas_DF <- do.call(rbind, exposures_gwas)
#faster way of doing things with dplyr
exposures_gwas_DF <- bind_rows(exposures_gwas)

#check that 'phenotypes' is the same as the last entry in gwas_unique
# gwas_unique[3590]
# gwas_phenotypes$Phenotype

# 
# save(exposures_gwas, file = "C:/Users/me/Desktop/MPH/Internship/CPMC/exposures_gwas.Rdata")
```

#### b. MR Base GWAS Catalog

#### c. Gene Expression QTLs
should we search for gene and tissue together or just gene?
- below is search by gene and tissue together
```{r, cache = TRUE}

#import Gene Expression QTLs list
data(gtex_eqtl)
gtex_eqtl


#create a list of unique gene names

genes_unique <- gtex_eqtl[!duplicated(gtex_eqtl$gene_name),] %>% pull(gene_name)

# 32432 unique gene names
```


For loop
```{r, cache = TRUE}
genes_table <- gtex_eqtl[!duplicated(gtex_eqtl$gene_name),]

exposures_genes <- data.frame()
for(i in 17583: length(genes_unique)){
  genes <- subset(gtex_eqtl, gene_name == genes_unique[i])

  #create a separate clumping step in case LD lookup times out
  genes_format <- format_gtex_eqtl(genes) %>% clump_data()

  exposures_genes <- rbind(exposures_genes, genes_format)
}

saveRDS(exposures_genes, file = "C:/Users/me/Desktop/MPH/Internship/CPMC/exposures_genes.rds")
```


try as a function

```{r, cache = TRUE}
genes_clump <- function(genes){
  gene <- subset(gtex_eqtl, gene_name == genes) %>% format_gtex_eqtl() %>% clump_data()
}

gen <- genes_unique[1:10]

test <- lapply(gen, genes_clump)
```

try local clumping
reference downloaded at : http://fileserve.mrcieu.ac.uk/ld/1kg.v3.tgz
```{r,cache=TRUE}


#format for ld_clumping

gene_dat <-subset(gtex_eqtl, gene_name == "RP4-669L17.10") %>% 
  format_gtex_eqtl() %>%
  rename(rsid = SNP,
         pval = pval.exposure,
         id = id.exposure) %>%
  ld_clump(plink_bin = genetics.binaRies::get_plink_binary(), bfile = "C:/Users/me/Desktop/MPH/Internship/CPMC/Data/LD_reference/EUR", #no need to include extensions
           clump_kb = 1000, clump_r2 = .001, 
           clump_p = 1, pop = "EUR") 
 

#same results
```



#### d. Protein Level QTLs

Instead of retrieving via API, do ld clumping locally using the same reference population "EUR" from 1000 genomes

```{r, cache=TRUE}
#import Protein Level QTLs into R
data(proteomic_qtls)
proteomic_qtls

#create a list of unique protein analyte & make a list

proteins_unique <- proteomic_qtls[!duplicated(proteomic_qtls$analyte),] %>% pull(analyte)


exposures_protein <- data.frame()
for(i in 1 : length(proteins_unique)) {
  
  proteins_phenotypes<- subset(proteomic_qtls, analyte == proteins_unique[i])
  
  #format exposure data and clump by LD r2 <0.001 to reduce covariance
  proteins_format<- proteins_phenotypes %>% format_proteomic_qtls() %>%
    rename(rsid = SNP,
         pval = pval.exposure,
         id = id.exposure)
  
  proteins_clump <- ld_clump(proteins_format, 
                             plink_bin = genetics.binaRies::get_plink_binary(), 
                             bfile = "C:/Users/me/Desktop/MPH/Internship/CPMC/Data/LD_reference/EUR",
                             #no need to include extensions
                             clump_kb = 1000, clump_r2 = .001, clump_p = 1, pop = "EUR")

  exposures_protein <- rbind(exposures_protein, proteins_clump)
    
}

exposures_protein <- exposures_protein %>% rename (SNP = rsid, id.exposure = id)

```



For Loops
```{r, cache = TRUE}

#import Protein Level QTLs into R
data(proteomic_qtls)
proteomic_qtls

#create a list of unique protein analyte & make a list

proteins_unique <- proteomic_qtls[!duplicated(proteomic_qtls$analyte),] %>% pull(analyte)
#  unique phenotypes in catalog



#make a for loop to create a database of exposure SNPs formatted for exposure data and clumped
exposures_proteins_API <- data.frame()
for(i in 1 : length(proteins_unique)) {
  
  proteins_phenotypes_API<- subset(proteomic_qtls, analyte == proteins_unique[i])
  
  #format exposure data and clump by LD r2 <0.001 to reduce covariance
  proteins_format_API<- proteins_phenotypes_API %>% format_proteomic_qtls() %>% clump_data()

  exposures_proteins_API <- rbind(exposures_proteins_API, proteins_format_API)
    
}


# check that 'phenotypes' is the same as the last entry in gwas_unique
proteins_unique[47]
proteins_phenotypes$analyte


saveRDS(exposures_proteins_API, file = "C:/Users/me/Desktop/MPH/Internship/CPMC/exposures_proteins.rds")
```

Both dataframes are the same. 

```{r,cache=TRUE}
identical(exposures_protein$rsid, exposures_proteins_API$rsid)
```


#### e. Metabolite Level OTLs


```{r, cache=TRUE}

#import Metabolite Level QTLs into R
data(metab_qtls)
metab_qtls

#create a list of unique metabolomic phenotype & make a list

metabolites_unique <- metab_qtls[!duplicated(metab_qtls$phenotype),] %>% pull(phenotype)
# 121 unique phenotypes in catalog



#make a for loop to create a database of exposure SNPs formatted for exposure data and clumped
exposures_metabolite <- data.frame()
for(i in 1 : length(metabolites_unique)) {
  
  metabolites_phenotypes<- subset(metab_qtls, phenotype == metabolites_unique[i]) %>% 
    format_metab_qtls() %>% 
    rename(rsid = SNP,
         pval = pval.exposure,
         id = id.exposure) %>%
    ld_clump( plink_bin = genetics.binaRies::get_plink_binary(), 
              bfile = "C:/Users/me/Desktop/MPH/Internship/CPMC/Data/LD_reference/EUR",
              clump_kb = 1000, clump_r2 = .001, clump_p = 1, pop = "EUR")
    

  exposures_metabolite <- rbind(exposures_metabolite, metabolites_phenotypes)
    
}

exposures_metabolite <- exposures_metabolite %>% rename (SNP = rsid, id.exposure = id)  
  
#check that 'phenotypes' is the same as the last entry in metabolites_unique
metabolites_unique[121]
metabolites_phenotypes$phenotype


saveRDS(exposures_metabolite, file = "C:/Users/me/Desktop/MPH/Internship/CPMC/exposures_metabolites.rds")
```

#### f. Methylation Level QTLs
by cpg site and age



```{r}

#import Methylation Level QTLs into R
data(aries_mqtl)
aries_mqtl

#create a list of unique Methylation  cpg & make a list

methylation_unique <- aries_mqtl[!duplicated(aries_mqtl$cpg),]%>% pull(cpg)
age <- c("Birth", "Adolescence", "Childhood", "Middle age", "Pregnancy")
#  33256 unique cpg sites in catalog
# 5 'ages'

#make a for loop to create a database of exposure SNPs formatted for exposure data and clumped


exposures_methylation <- data.frame()
for (j in 1:5){
  for(i in 1 : 33256) {
  
    methylation_phenotypes<- subset(aries_mqtl, cpg == methylation_unique[i] & age == age[j])%>% 
      format_aries_mqtl() %>% 
      rename(rsid = SNP,
         pval = pval.exposure,
         id = id.exposure) %>%
    ld_clump( plink_bin = genetics.binaRies::get_plink_binary(), 
              bfile = "C:/Users/me/Desktop/MPH/Internship/CPMC/Data/LD_reference/EUR",
              clump_kb = 1000, clump_r2 = .001, clump_p = 1, pop = "EUR")
    
    
  exposures_methylation <- rbind(exposures_methylation, methylation_phenotypes)
     

    
    
  }


}

exposures_methylation <- exposures_methylation %>% rename (SNP = rsid, id.exposure = id)   
#check that 'phenotypes' is the same as the last entry in metabolites_unique
methylation_unique[33256]
methylation_phenotypes$cpg


saveRDS(exposures_methylation, file = "C:/Users/me/Desktop/MPH/Internship/CPMC/exposures_methylation.rds")
```


